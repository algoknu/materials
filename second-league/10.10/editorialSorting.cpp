/**
В задачі А потрібно було відсортувати масив будь-яким зручним методом,
наприклад, сортуванням вибором чи якимось іншим, обмеження дозволяли 
використати будь-який із них
*/
void problemA(int a[], int n) {
	for(int i = 0; i < n - 1; i++) {
		int m = i;
		for(int j = i + 1; j < n; j++) {
			if(a[j] < m) m = j;
		}
		swap(a[i], a[m]);
	}
}

/**
В задачі B потрібно було відсортувати масив сортуванням бульбашкою, 
лише з тією відмінністю, що після кожної ітерації 
потрібно було вивести стан масиву
*/

void problemB(int a[], int n) {
	for(int i = 0; i < n - 1; i++) {
		for(int j = 1; j < n - i;j++) {
			if(a[j] < a[j - 1]) {
				swap(a[j], a[j - 1]);
			}
		}
		for(int i = 0; i < n; i++) {
			cout << a[i] << " ";
		}
		cout << "\n";
	}
}

/**
В задачі С основною ідеєю розв'язку було те, 
що рядки є анаграмами коли відповідні їм відсортовані рядки є одинакові
Сортування рядка є ідентичним сортуванню послідовності чисел,
обмеження дозволяють викорисати будь-який з методів
*/

void problemC(string a, string b) {
	/// sortString - деяка функція сортування рядка
	sortString(a);
	sortString(b);
	cout << (a == b ? "YES" : "NO"); 
}

/**
В задачі D будемо сортувати пари вигляду (points, position) 
і сортувати за неспаданням балів(у випадку рівності - за неспаданням номера)
*/

void problemD(int a[], int pos[], int n) {
	for(int i = 1; i <= n; i++) {
		pos[i] = i;
	}
	for(int i = 1; i < n; i++) {
		int m = i;
		for(int j = i + 1; j <= n; j++) {
			if(a[m] != a[j]) {
				if(a[m] < a[j]) {
					m = j;
				}
			}
			else {
				if(pos[m] > pos[j]) {
					m = j;
				}
			}
		}
		swap(a[m], a[i]);
		swap(pos[m], pos[i]);
	}
}

/**
Складність задачі E полягала в тому, щоб після сортування розташувати елементи
в порядку, вказаному в умові. Нижче наведений код,
 який розташовує числа в потрібному порядку в масив b, якщо масив a відсортований :
*/

void problemE(int a[], int b[] int n) {
	for(int i = 0; i < n; i++) {
		if(i % 2 == 0) {
			b[i / 2] = a[i]; 
		}
		else {
			b[n - 1 - i / 2] = a[i];
		}
	}
}

/**
В задачі F аналогічно з задачею D зберігаємо пари (lastDigit, number) 
і сортуємо їх
*/

void problemF(int a[], int lastDigit[], int n) {
	for(int i = 1; i <= n; i++) {
		lastDigit[i] = a[i] % 10;
	}
	for(int i = 1; i < n; i++) {
		int m = i;
		for(int j = i + 1; j <= n; j++) {
			if(lastDigit[m] != lastDigit[j]) {
				if(a[m] > a[j]) {
					m = j;
				}
			}
			else {
				if(lastDigit[m] > lastDigit[j]) {
					m = j;
				}
			}
		}
		swap(a[m], a[i]);
		swap(lastDigit[m], lastDigit[i]);
	}
}

/**
Задачу G можна було розв'язувати аналогічно попередній, 
використавши 3 пріоритети, але можна набагато простіше : порівнювати час, 
приведений до секунд і на основі цього сортувати послідовність
*/


void problemG(int h[], int m[], int s[], int n) {
	for(int i = 0; i < n - 1; i++) {
		int k = i;
		for(int j = i + 1; j < n; j++) {
			if(h[k] * 3600 + m[k] * 60 + s[k] > 
				h[j] * 3600 + m[j] * 60 + s[j]) {
					k = j;
				}
		}
		swap(h[k], h[i]);
		swap(m[k], m[i]);
		swap(s[k], s[i]);
	}	
}

/**
Задача H
Твердження : якщо за допомогою якогось набору чисел A 
ми можемо утворити всі числа від 1..s, то за допомогою набору A+{x}, де s + 1 >= x 
ми зможемо утворити всі числа від 1..(s + x)

Доведення : оскільки додвавння елемента нічого не погіршує, то ми завжди зможемо утворити 
числа 1..s, залишилось довести можливість утворення чисел (s + 1)...(s + x), 
оскільки s + 1 >= x, то ми можемо використати елемент x і тоді зведемо задачу до
утворення чисел (s - x + 1)..s для набору A, що можливо за умовою.
  
Відсортуємо елементи масива за неспаданням, тоді
розгялнемо два випадки :
1.a[0] != 1, тоді відповідь 1;
2.a[0] = 1, тоді вважатимемо s рівним 1 і для наступних 
елементів спробуємо покращити відповідь за допомогою нашого твердження, 
якщо в якомусь випадку s + 1 < a[i], то s + 1 і буде відповідю

*/


int problemH(int a[], int n) {
	///сортуємо масив
	long long s = 0;
	if(a[0] != 1) {
		return 1;
	}
	s += a[0];
	for(int i = 1; i < n; i++) {
		if(s + 1 < a[i]) {
			return s + 1;
		}
		s += a[i];
	}
	return s + 1;
}

/**
Складність задачі І полягала в тому, щоб сортувати за багатьма пріоритетами одразу,
алгоритмічного навантаження вона не несла.
*/

/// структура, що описує учня
struct Student {
	int form; char letter;
	string surname, name, date;
};

/// функція порівняння, повертає true, якщо перший студент 
/// має бути в списку раніше ніж другий і false в іншому випадку
bool compare(Student lhs, Student rhs) {
	if(lhs.form != rhs.form) {
		return lhs.form < rhs.form;
	}
	else {
		if(lhs.letter != rhs.letter) {
			return lhs.letter < rhs.letter;
		}
		else {
			return lhs.surname < rhs.surname;
		}
	}
}

void problemI(Student a[], int n) {
	for(int i = 0; i < n - 1; i++) {
		int m = i;
		for(int j = i + 1; j < n; j++) {
			if(compare(a[j], a[m]) {
				m = j;
			}
		}
		swap(a[i], a[m]);
	}
}


/**
Безперечно, задачу J можна було розв*язувати за допомогою 
якого-небудь логарифмічного сортування(наприклад, сортування злиттям),
але авторський розв*язок не передабачає використання сортування і має
складніть O(N).
Суть сортування полягає в знаходженні найменшого і додаванні в кінець послідовності, 
але в нашому випадку найменший елемент - це перший елемент одної з послідовностей,
тож ми можемо додавати цей елемент в кінець відосортованої послідовності і видаляти з
початку попередньої послідовності
В реалізації явного видаляння, і додавання,звісно не буде, просто будемо зберігати 
початок і кінець послідовностей
*/

void problemJ(int a[], int b[], int result[], int n) {
	for(int i = 0, j = 0, k = 0; i < n; i++) {
		while(j < n && a[j] <= a[i]) {
			result[k] = a[j];
			j++;k++;
		}
		result[k] = a[i];
		k++;
		if(i == n - 1) {
			while(j < n) {
				result[k] = a[j];
				k++;j++;
			}
		}
	}
}